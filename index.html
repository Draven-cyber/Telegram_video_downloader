import os
import asyncio
import logging
from flask import Flask, render_template, request, send_file, jsonify, session
from telethon import TelegramClient
from telethon.errors import SessionPasswordNeededError
import hashlib
import time
import threading
import queue
import uuid
from functools import wraps
from pymongo import MongoClient
from datetime import datetime, timedelta
import gridfs
from bson import ObjectId
import certifi

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

app = Flask(__name__)
app.secret_key = os.urandom(24).hex()
app.config['SESSION_TYPE'] = 'filesystem'
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(hours=24)

# MongoDB Configuration
MONGODB_URI = "mongodb+srv://rithika:Rithika25894@cluster1.zuujlbq.mongodb.net/"
DB_NAME = "telegram_downloader"

# Connect to MongoDB
try:
    mongo_client = MongoClient(MONGODB_URI, tlsCAFile=certifi.where())
    db = mongo_client[DB_NAME]
    
    # Collections
    sessions_collection = db['sessions']
    files_collection = db['files']
    tasks_collection = db['tasks']
    
    # Create indexes
    sessions_collection.create_index('created_at', expireAfterSeconds=86400)  # Auto-delete after 24 hours
    files_collection.create_index('created_at', expireAfterSeconds=3600)  # Auto-delete after 1 hour
    tasks_collection.create_index('created_at', expireAfterSeconds=3600)
    
    # GridFS for file storage
    fs = gridfs.GridFS(db)
    
    logger.info("MongoDB connected successfully")
except Exception as e:
    logger.error(f"MongoDB connection error: {e}")
    raise e

# Your Telegram API credentials
API_ID = '29145458'
API_HASH = '00b32d6c9f385662edfed86f047b4116'

# Store active clients
clients = {}
download_queue = queue.Queue()
loop_per_thread = {}

def async_handler(f):
    """Decorator to handle async functions in Flask routes"""
    @wraps(f)
    def wrapped(*args, **kwargs):
        thread_id = threading.get_ident()
        if thread_id not in loop_per_thread:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            loop_per_thread[thread_id] = loop
        else:
            loop = loop_per_thread[thread_id]
        
        return loop.run_until_complete(f(*args, **kwargs))
    return wrapped

class TelegramDownloader:
    def __init__(self, session_id):
        self.session_id = session_id
        self.client = None
        self.loop = None
        
    async def init_client(self):
        """Initialize the client with proper event loop"""
        self.loop = asyncio.get_event_loop()
        
        # Check if we have a stored session in MongoDB
        stored_session = sessions_collection.find_one({'session_id': self.session_id})
        
        if stored_session and 'session_string' in stored_session:
            # Use stored session
            self.client = TelegramClient(
                StringSession(stored_session['session_string']), 
                API_ID, 
                API_HASH, 
                loop=self.loop
            )
        else:
            # Create new session
            self.client = TelegramClient(
                f'sessions/{self.session_id}', 
                API_ID, 
                API_HASH, 
                loop=self.loop
            )
        
    async def connect(self):
        """Connect to Telegram"""
        if not self.client:
            await self.init_client()
        await self.client.connect()
        
    async def disconnect(self):
        """Disconnect from Telegram"""
        if self.client and self.client.is_connected():
            await self.client.disconnect()
            
    async def is_authorized(self):
        """Check if user is authorized"""
        return await self.client.is_user_authorized()
        
    async def send_code(self, phone):
        """Send verification code"""
        return await self.client.send_code_request(phone)
        
    async def sign_in(self, phone, code):
        """Sign in with code"""
        result = await self.client.sign_in(phone, code)
        
        # Store session in MongoDB
        if await self.client.is_user_authorized():
            session_string = StringSession.save(self.client.session)
            sessions_collection.update_one(
                {'session_id': self.session_id},
                {
                    '$set': {
                        'session_string': session_string,
                        'phone': phone,
                        'created_at': datetime.utcnow()
                    }
                },
                upsert=True
            )
        
        return result
        
    async def get_message(self, message_link):
        """Extract message info from Telegram link"""
        try:
            # Parse the message link
            parts = [p for p in message_link.split('/') if p]
            message_id = int(parts[-1])
            
            if 'c' in parts:
                # Private channel
                chat_id_index = parts.index('c') + 1
                chat_id = int(parts[chat_id_index])
                entity = await self.client.get_entity(int(f'-100{chat_id}'))
            else:
                # Public chat
                chat_username = parts[-2]
                if chat_username in ['t.me', 'telegram.me']:
                    chat_username = parts[-3]
                entity = await self.client.get_entity(chat_username)
            
            message = await self.client.get_messages(entity, ids=message_id)
            return message
        except Exception as e:
            logger.error(f"Error getting message: {e}")
            return None
    
    async def download_media(self, message, download_id):
        """Download media from message"""
        try:
            if message and message.media:
                # Generate filename
                if hasattr(message.media, 'photo'):
                    ext = '.jpg'
                    filename = f"photo_{message.id}{ext}"
                elif hasattr(message.media, 'document'):
                    filename = None
                    for attr in message.media.document.attributes:
                        if hasattr(attr, 'file_name'):
                            filename = attr.file_name
                            break
                    
                    if not filename:
                        mime_type = message.media.document.mime_type
                        if mime_type:
                            ext = mime_type.split('/')[-1]
                            if ext == 'plain':
                                ext = 'txt'
                            elif ext == 'jpeg':
                                ext = 'jpg'
                        else:
                            ext = 'bin'
                        filename = f"document_{message.id}.{ext}"
                else:
                    return None, "Unsupported media type"
                
                # Download to temporary file
                temp_path = f"/tmp/{download_id}_{filename}"
                path = await message.download_media(file=temp_path)
                
                if path and os.path.exists(path):
                    # Store in MongoDB GridFS
                    with open(path, 'rb') as f:
                        file_id = fs.put(
                            f,
                            filename=filename,
                            metadata={
                                'download_id': download_id,
                                'original_name': filename,
                                'created_at': datetime.utcnow()
                            }
                        )
                    
                    # Store file info in MongoDB
                    files_collection.insert_one({
                        'file_id': str(file_id),
                        'download_id': download_id,
                        'filename': filename,
                        'created_at': datetime.utcnow()
                    })
                    
                    # Clean up temp file
                    os.remove(path)
                    
                    return str(file_id), filename
                else:
                    return None, "Download failed"
            else:
                return None, "No media found in message"
        except Exception as e:
            logger.error(f"Download error: {e}")
            return None, str(e)

# Background worker for handling downloads
def download_worker():
    """Background thread to process downloads"""
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    
    while True:
        try:
            task = download_queue.get(timeout=1)
            if task:
                download_id, message_link, session_id = task
                
                async def process_download():
                    downloader = None
                    try:
                        # Update task in MongoDB
                        tasks_collection.insert_one({
                            'download_id': download_id,
                            'status': 'queued',
                            'progress': 0,
                            'created_at': datetime.utcnow()
                        })
                        
                        downloader = TelegramDownloader(session_id)
                        await downloader.connect()
                        
                        if not await downloader.is_authorized():
                            tasks_collection.update_one(
                                {'download_id': download_id},
                                {'$set': {
                                    'status': 'error',
                                    'message': 'Session expired. Please log in again.'
                                }}
                            )
                            return
                        
                        tasks_collection.update_one(
                            {'download_id': download_id},
                            {'$set': {'status': 'processing', 'progress': 10}}
                        )
                        
                        message = await downloader.get_message(message_link)
                        
                        if not message:
                            tasks_collection.update_one(
                                {'download_id': download_id},
                                {'$set': {
                                    'status': 'error',
                                    'message': 'Message not found or inaccessible.'
                                }}
                            )
                            return
                        
                        tasks_collection.update_one(
                            {'download_id': download_id},
                            {'$set': {'status': 'downloading', 'progress': 30}}
                        )
                        
                        file_id, filename = await downloader.download_media(message, download_id)
                        
                        if file_id:
                            tasks_collection.update_one(
                                {'download_id': download_id},
                                {'$set': {
                                    'status': 'completed',
                                    'file_id': file_id,
                                    'filename': filename,
                                    'progress': 100
                                }}
                            )
                            logger.info(f"Download completed: {filename}")
                        else:
                            tasks_collection.update_one(
                                {'download_id': download_id},
                                {'$set': {
                                    'status': 'error',
                                    'message': filename
                                }}
                            )
                            
                    except Exception as e:
                        logger.error(f"Download error: {e}")
                        tasks_collection.update_one(
                            {'download_id': download_id},
                            {'$set': {
                                'status': 'error',
                                'message': str(e)
                            }}
                        )
                    finally:
                        if downloader:
                            await downloader.disconnect()
                
                loop.run_until_complete(process_download())
                
        except queue.Empty:
            pass
        except Exception as e:
            logger.error(f"Worker error: {e}")

# Start background worker thread
worker_thread = threading.Thread(target=download_worker, daemon=True)
worker_thread.start()

@app.route('/')
def index():
    """Main page"""
    return render_template('index.html')

@app.route('/login', methods=['POST'])
@async_handler
async def login():
    """Handle Telegram login"""
    try:
        data = request.get_json()
        phone = data.get('phone')
        
        if not phone:
            return jsonify({'success': False, 'error': 'Phone number required'})
        
        session_id = str(uuid.uuid4())
        session['telegram_session'] = session_id
        
        downloader = TelegramDownloader(session_id)
        await downloader.connect()
        clients[session_id] = downloader
        
        result = await downloader.send_code(phone)
        
        return jsonify({
            'success': True,
            'message': 'Code sent successfully',
            'phone_code_hash': getattr(result, 'phone_code_hash', '')
        })
        
    except Exception as e:
        logger.error(f"Login error: {e}")
        return jsonify({'success': False, 'error': str(e)})

@app.route('/verify', methods=['POST'])
@async_handler
async def verify():
    """Verify login code"""
    try:
        data = request.get_json()
        code = data.get('code')
        phone = data.get('phone')
        session_id = session.get('telegram_session')
        
        if not session_id or session_id not in clients:
            return jsonify({'success': False, 'error': 'No active session. Please start over.'})
        
        downloader = clients[session_id]
        
        try:
            await downloader.sign_in(phone, code)
            return jsonify({'success': True})
        except SessionPasswordNeededError:
            return jsonify({'success': False, 'error': 'Two-factor authentication enabled. This version doesn\'t support 2FA yet.'})
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)})
        
    except Exception as e:
        logger.error(f"Verification error: {e}")
        return jsonify({'success': False, 'error': str(e)})

@app.route('/download', methods=['POST'])
def download():
    """Start download process"""
    try:
        data = request.get_json()
        message_link = data.get('link')
        session_id = session.get('telegram_session')
        
        if not session_id:
            return jsonify({'success': False, 'error': 'Please log in first'})
        
        if session_id not in clients:
            return jsonify({'success': False, 'error': 'Session expired. Please log in again.'})
        
        if not message_link:
            return jsonify({'success': False, 'error': 'Message link required'})
        
        if 't.me/' not in message_link:
            return jsonify({'success': False, 'error': 'Invalid Telegram link format'})
        
        download_id = hashlib.md5(f"{message_link}{time.time()}".encode()).hexdigest()[:8]
        
        download_queue.put((download_id, message_link, session_id))
        
        return jsonify({
            'success': True,
            'download_id': download_id,
            'message': 'Download started'
        })
        
    except Exception as e:
        logger.error(f"Download request error: {e}")
        return jsonify({'success': False, 'error': str(e)})

@app.route('/status/<download_id>')
def get_status(download_id):
    """Get download status from MongoDB"""
    try:
        task = tasks_collection.find_one({'download_id': download_id})
        
        if task:
            if task['status'] == 'completed':
                return jsonify({
                    'status': 'completed',
                    'filename': task.get('filename'),
                    'download_url': f'/file/{download_id}'
                })
            elif task['status'] == 'error':
                return jsonify({
                    'status': 'error',
                    'message': task.get('message', 'Unknown error')
                })
            else:
                return jsonify({
                    'status': task['status'],
                    'progress': task.get('progress', 0)
                })
        else:
            return jsonify({'status': 'not_found'})
            
    except Exception as e:
        logger.error(f"Status check error: {e}")
        return jsonify({'status': 'error', 'message': str(e)})

@app.route('/file/<download_id>')
def download_file(download_id):
    """Serve downloaded file from MongoDB GridFS"""
    try:
        # Find file in MongoDB
        file_info = files_collection.find_one({'download_id': download_id})
        
        if file_info and 'file_id' in file_info:
            file_id = ObjectId(file_info['file_id'])
            
            # Get file from GridFS
            grid_file = fs.get(file_id)
            
            if grid_file:
                # Send file
                response = send_file(
                    grid_file,
                    as_attachment=True,
                    download_name=file_info['filename'],
                    mimetype='application/octet-stream'
                )
                
                # Update download count
                files_collection.update_one(
                    {'download_id': download_id},
                    {'$inc': {'download_count': 1}}
                )
                
                return response
        
        return "File not found or expired", 404
        
    except Exception as e:
        logger.error(f"File download error: {e}")
        return "Error downloading file", 500

@app.route('/logout')
@async_handler
async def logout():
    """Logout from Telegram"""
    session_id = session.get('telegram_session')
    if session_id and session_id in clients:
        try:
            downloader = clients[session_id]
            await downloader.disconnect()
            del clients[session_id]
            
            # Remove session from MongoDB
            sessions_collection.delete_one({'session_id': session_id})
            
        except Exception as e:
            logger.error(f"Logout error: {e}")
    
    session.clear()
    
    return jsonify({'success': True})

@app.route('/check-auth')
@async_handler
async def check_auth():
    """Check if user is authenticated"""
    session_id = session.get('telegram_session')
    if session_id and session_id in clients:
        try:
            downloader = clients[session_id]
            if await downloader.is_authorized():
                return jsonify({'authenticated': True})
        except:
            pass
    
    return jsonify({'authenticated': False})

@app.route('/cleanup', methods=['POST'])
def cleanup():
    """Manual cleanup endpoint (optional)"""
    try:
        # Delete old files
        cutoff = datetime.utcnow() - timedelta(hours=1)
        old_files = files_collection.find({'created_at': {'$lt': cutoff}})
        
        for file_info in old_files:
            if 'file_id' in file_info:
                try:
                    fs.delete(ObjectId(file_info['file_id']))
                except:
                    pass
            files_collection.delete_one({'_id': file_info['_id']})
        
        # Delete old tasks
        tasks_collection.delete_many({'created_at': {'$lt': cutoff}})
        
        return jsonify({'success': True, 'message': 'Cleanup completed'})
        
    except Exception as e:
        logger.error(f"Cleanup error: {e}")
        return jsonify({'success': False, 'error': str(e)})

# Create necessary directories
os.makedirs('sessions', exist_ok=True)
os.makedirs('templates', exist_ok=True)
os.makedirs('/tmp', exist_ok=True)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True, threaded=True)
